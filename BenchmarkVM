# Importando as bibliotecas necessárias
import libvirt
import csv
import datetime as dt
import time
import tkinter as tk

# Nomes das VMs que serão monitoradas
vm_names = ["java11", "java8"]  

# Tempo de medição em segundos
measurement_time = 5   

# Intervalo de medição em segundos
measurement_interval = 2  

# Função para escrever os dados em um arquivo CSV
def write_csv(filename, headers, rows):
    with open(filename, 'w', newline='') as file:
        writer = csv.writer(file)
        try:
            writer.writerow(headers)
            writer.writerows(rows)
        except Exception as e:
            print(f'Erro ao escrever arquivo {filename}: {e}')
            exit(1)
        finally:	
            file.close()

# Função para coletar as estatísticas de uma VM
def gather_vm_stats(conn, vm):
    stats_cpu = vm.getCPUStats(True)
    stats_mem = vm.memoryStats()
    return {
        "VM": vm.name(), # Nome da VM sendo monitorada
        "Horário de Medição": dt.datetime.now().strftime("%H:%M:%S"), # Data e hora do momento da medição
        "Tempo de CPU (ns)": stats_cpu[0]['cpu_time'], # Tempo total de CPU usado pela VM (em nanosegundos)
        "Tempo de Sistema (ns)": stats_cpu[0]['system_time'], # Tempo total do sistema usado pela VM (em nanosegundos)
        "Tempo de Usuário (ns)": stats_cpu[0]['user_time'], # Tempo total de usuário usado pela VM (em nanosegundos)
        "Memória Alocada (B)": stats_mem.get("actual"), # Quantidade de memória alocada (em bytes)
        "Memória Não Utilizada (B)": stats_mem.get("unused"), # Quantidade de memória não utilizada (em bytes)
        "Memória Disponível (B)": stats_mem.get("available"), # Quantidade de memória disponível (em bytes)
        "Memória Usável (B)": stats_mem.get("usable"), # Quantidade de memória usável (em bytes)
        "Caches de Disco (B)": stats_mem.get("disk_caches", 0) # Quantidade de caches de disco usados (em bytes)
    }

# Abre conexão com qemu:///system e armazena as VMs
# Define as colunas do cabeçalho da tabela CSV e inicializa a lista de linhas vazia
def start_benchmark():
    # Abre conexão com qemu:///system
    conn = libvirt.open('qemu:///system')
    if not conn:
        raise Exception('Falha ao abrir conexão com qemu:///system')

    # Armazena as VMs
    vms = []
    for name in vm_names:
        vm = conn.lookupByName(name)
        if not vm:
            raise Exception(f'Falha ao encontrar a VM {name}')
        vms.append(vm)

    # Define as colunas do cabeçalho da tabela CSV
    headers = list(gather_vm_stats(conn, vms[0]).keys())

    # Inicializa a lista de linhas vazia
    rows = []

    # Executa o benchmark por um tempo específico com intervalos regulares
    end_time = time.time() + measurement_time
    while time.time() < end_time:
        for vm in vms:
            rows.append(gather_vm_stats(conn, vm))
        time.sleep(measurement_interval)

    # Escreve os dados coletados em um arquivo CSV
    write_csv("benchmark.csv", headers, [list(row.values()) for row in rows])

    # Fecha a conexão com libvirt e encerra o programa
    conn.close()
    print("Benchmark concluído com sucesso!")
    root.quit()

# Cria a janela principal da interface gráfica
root = tk.Tk()
root.title("Benchmark VMs")

# Adiciona um botão para iniciar o benchmark
start_button = tk.Button(root, text="Iniciar Benchmark", command=start_benchmark)
start_button.pack()

# Inicia o loop de eventos da interface gráfica
root.mainloop()

